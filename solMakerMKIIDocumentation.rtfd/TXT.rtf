{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11260\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Outline:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li580\fi-580\ql\qnatural\pardirnatural
\cf0 	The Sol-Maker MKII is a shield designed for the Arduino Uno. This shield allows for individual control of up to twelve solenoids (push, pull, or rotary) utilizing an external power supply; 12 or 24 volts depending on the power requirements of the solenoids. Control of each solenoid is made possible by communication with each of the 12 output pins on the Arduino Uno\'961 pin per solenoid. The current code allows the user to send messages on/off messages from a computer to the Arduino via the USB port.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
Circuit:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li580\fi-580\ql\qnatural\pardirnatural
\cf0 	The design of the circuit is quite simple. Each of the 12 digital outputs of the Arduino Uno (outputs 2 to 13) are connected to identical modules. Each module contains a resistor, a TIP 120 transistor, and a diode. These modules allow the shared voltage (12 or 24 volt external power supply) to be controlled by the digital output of the Arduino for each solenoid.\
\
	In each module the TIP120 acts as a gate which is opened and closed by the 5 volt output from the digital output pins of the Arduino. The resistor is necessary since the TIP120  provides very low impedance and so without it the Arduino could be damaged. \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\fi-1120\ql\qnatural\pardirnatural
\cf0 		A diode is run in parallel with each solenoid. This is necessary because solenoids are inductors and after a solenoid is cycled (charged and released) the plunger returns to the starting point. This returning plunger pushes current the opposite direction in the circuit and so without the diode this reversed current could potentially damage the transistor.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li580\fi-580\ql\qnatural\pardirnatural
\cf0 \
	In the second section of each module contains a resistor and an light emitting diode (LED). This section is connected in parallel to each of the digital output pins which control the solenoids. When a solenoid is activated, a corresponding LED is activated. The LEDs are powered by the 5V provided by the digital outputs and do not utilize the external power supply. \
\
		The resistor provides the same function as the TIP120's resistor. \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\fi-1120\ql\qnatural\pardirnatural
\cf0 		The LED provides visual feedback and, since it will continue to operate when the external power supply is not on and when a solenoid is not connected, it notifies the user which module is being activated. This is advantageous for fault checking during system setup (i.e. finding out which output you are controlling before plugging a solenoid into that modules output).\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
	Solenoids:\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1140\fi-1140\ql\qnatural\pardirnatural
\cf0 		Any solenoid with a voltage range of 12 to 24 volts should work with this circuit. There is a possibility of damaging a solenoid by holding current for too long if it is not designed to hold for long periods of time.\
\
	Resistor Values:\
		2.2kOhm for each resistor matched with a TIP120.\
		1.\
\
	Diodes:\
		Any diode rated for an appropriate amount of current ***MEASURE!\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
Control:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li580\fi-580\ql\qnatural\pardirnatural
\cf0 	Control is possible utilizing the USB port on the Arduino. The code (outline below) allows the user to send an on/off byte to each solenoid individually by coupling the byte with an address. Thus, although Max/MSP has been utilized for control, any programming language or software can be used as long as the following serial message format is maintained:\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\fi-1120\ql\qnatural\pardirnatural
\cf0 		
\b on/off byte (ascii character 48 for 0 and ascii character 49 for 1) +  solenoid channel byte (ascii value from 'a' to 'l'; 97 to 108) +  32 (ascii value for blank space) + 13 (ascii value for carriage return)\
\
			
\b0 example: 0 97 32 13 will cause solenoid #1 to turn off\
\
	Arduino Code:\
		\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\ql\qnatural\pardirnatural
\cf0 char buffer[40]; // stores data from serial.\
int index = 0;\
\
// channels represent HIGH/LOW state of each output\
int channelA, channelB, channelC, channelD, channelE, channelF, channelG, channelH, channelI, channelJ, channelK, channelL;\
\
int highLowDeterm(int x) // converts int into HIGH or LOW for digitalWrite\
\{\
  int returnValue;\
  \
  if(x > 0)\
  \{\
    returnValue = 0x1;\
  \}\
  else\
  \{\
    returnValue = 0x0;\
  \} \
  \
  return returnValue;\
\}\
\
void setup()   \
\{                \
  Serial.begin(115200);\
  for(int n = 2; n <  14; n++) //sets pins 2 to 13 to output mode\
  \{\
    pinMode(n, OUTPUT);\
  \}\
\}\
\
void loop()                     \
\{\
  index = 0;\
  do\
  \{\
    buffer[index] = Serial.read();  // get a byte from the serial port\
    if (buffer[index]!=-1)\
    \{\
    index = index+1;    // -1 if no byte is present\
    \}\
    else if (buffer[index-1] == 97) // checks for ASCII code 'a'\
    \{\
      channelA = highLowDeterm(atoi(buffer)); // if 'a' convert input to int and convert to HIGH/LOW\
    \}\
    else if (buffer[index-1] == 98)\
    \{\
      channelB = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 99)\
    \{\
      channelC = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 100)\
    \{\
      channelD = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 101)\
    \{\
      channelE = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 102)\
    \{\
      channelF = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 103)\
    \{\
      channelG = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 104)\
    \{\
      channelH = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 105)\
    \{\
      channelI = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 106)\
    \{\
      channelJ = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 107)\
    \{\
      channelK = highLowDeterm(atoi(buffer));\
    \}\
    else if (buffer[index-1] == 108)\
    \{\
      channelL = highLowDeterm(atoi(buffer));\
    \}\
    \
  \} while (buffer[index-1] != 32);\
    \
    // Solenoids turned on/off\
    digitalWrite(2, channelA); \
    digitalWrite(3, channelB);\
    digitalWrite(4, channelC);\
    digitalWrite(5, channelD);\
    digitalWrite(6, channelE);\
    digitalWrite(7, channelF);\
    digitalWrite(8, channelG);\
    digitalWrite(9, channelH);\
    digitalWrite(10, channelI);\
    digitalWrite(11, channelJ);\
    digitalWrite(12, channelK);\
    digitalWrite(13, channelL);\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\fi-1120\ql\qnatural\pardirnatural
\cf0 	Max/MSP Patch Example:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\fi560\ql\qnatural\pardirnatural
\cf0 {{\NeXTGraphic sol-makerSimpleExample.png \width8774 \height5971
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\fi560\ql\qnatural\pardirnatural
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1120\fi-1120\ql\qnatural\pardirnatural
\cf0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 Dynamics:\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li560\fi-560\ql\qnatural\pardirnatural
\cf0 	Originally 
\i pulse width modulation 
\i0 (PWM) was used for all supported pins with the belief that control of the output voltage would be useful for the dynamic capability of the solenoids. This was unfortunate because the Arduino Uno only supports 6 pins for PWM. It became apparent, however, that PWM was unnecessary since the velocity of the solenoids can be effectively controlled with the hold-time (aka, length of time that current is pushed through a solenoid). Thus, if a solenoid is given current for 10ms it will hit with less force than if current is held for 20ms. Each solenoid is likely to have idiosyncrasies and thus method of calibration would be useful but a simple scaling of MIDI velocity (0 - 127) with a range of 5 - 200ms should suffice.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
Future Improvements:\
	- Multiplexer could be used to increase number of solenoids. An alternative would be to use an 	Arduino Mega which supports a larger number of digital output pins. \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li700\fi-700\ql\qnatural\pardirnatural
\cf0 	- Since the shield obscures the Arduino completely a serial send/receive light on the board would be useful.\
	\
	- With an Arduino network adapter shield the system could easily utilize Open Sound Control (OSC) making the whole system more user friendly.\
 \
}